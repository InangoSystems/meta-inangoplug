commit 6dd2e2bb71735b7f1db5f8aa6d9f9f9ff56b2f84
Author: Puz, Dmytro <d.puz@inango-systems.com>
Date:   Thu Jun 24 14:55:31 2021 +0300

     Adding am_id to the sk_buff structure

diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 7bcb4f2f0905..058ea3a9db8b 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -927,6 +927,10 @@ struct sk_buff {
     __u16               vpid_vlan_tci;
 #endif  /* CONFIG_TI_PACKET_PROCESSOR */
 
+	/* Max size of Datapath identifier of session is 128 bits long. This field is used for reactive Datapath session identification */
+	u32 ufid[4];
+	u32 am_id;
+
 	/* These elements must be at the end, see alloc_skb() for details.  */
 	sk_buff_data_t		tail;
 	sk_buff_data_t		end;
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index d0ff1a6b9a8e..d2d8ec73b4ea 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -197,6 +197,7 @@ struct sk_buff *__alloc_skb_head(gfp_t gfp_mask, int node)
         kmem_cache_free(skbuff_head_cache, skb);
         return NULL;
     }
+	skb->am_id = 0;
 	skb->head = NULL;
 	skb->truesize = sizeof(struct sk_buff);
 	atomic_set(&skb->users, 1);
@@ -384,6 +384,8 @@ struct sk_buff *__alloc_skb(unsigned int size, gfp_t gfp_mask,
     atomic_set(&shinfo->dataref, 1);
     kmemcheck_annotate_variable(shinfo->destructor_arg);
 
+    skb->am_id = 0;
+
     if(skb_init_intel(skb))
     {
         goto no_ppinfo;
@@ -463,6 +465,8 @@ struct sk_buff *__build_skb(void *data, unsigned int frag_size)
 	atomic_set(&shinfo->dataref, 1);
 	kmemcheck_annotate_variable(shinfo->destructor_arg);
 
+	skb->am_id = 0;
+
     if(skb_init_intel(skb))
     {
         kmem_cache_free(skbuff_head_cache, skb);
@@ -770,6 +774,8 @@ static void skb_release_data(struct sk_buff *skb)
 		kfree_skb_list(shinfo->frag_list);
 
 	skb_free_head(skb);
+
+	skb->am_id = 0;
 }
 
 /*
@@ -1095,6 +1101,9 @@ static struct sk_buff *__skb_clone(struct sk_buff *n, struct sk_buff *skb)
 
 	atomic_inc(&(skb_shinfo(skb)->dataref));
 	skb->cloned = 1;
+
+	C(am_id);
+
 #if IS_ENABLED(CONFIG_DIRECTCONNECT_DP_API)
 	/* used by directconnect peripherals to store session info */
 	n->DW0 = 0;
@@ -1276,6 +1285,9 @@ static void copy_skb_header(struct sk_buff *new, const struct sk_buff *old)
 	skb_shinfo(new)->gso_size = skb_shinfo(old)->gso_size;
 	skb_shinfo(new)->gso_segs = skb_shinfo(old)->gso_segs;
 	skb_shinfo(new)->gso_type = skb_shinfo(old)->gso_type;
+
+	new->am_id = old->am_id;
+
 #ifdef CONFIG_TI_META_DATA
     new->ti_meta_info = old->ti_meta_info;
     new->ti_meta_info2 = old->ti_meta_info2;
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index a3632a77fef6..8e7b4d0fa2c1 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -546,6 +546,8 @@ static void ip_copy_metadata(struct sk_buff *to, struct sk_buff *from)
 	to->dev = from->dev;
 	to->mark = from->mark;
 
+	to->am_id = from->am_id;
+
 	skb_copy_hash(to, from);
 
 	/* Copy the flags to each fragment. */
diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c
index 6d6f0774ee91..7bea331a0693 100644
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@ -603,6 +603,8 @@ static void ip6_copy_metadata(struct sk_buff *to, struct sk_buff *from)
 	to->dev = from->dev;
 	to->mark = from->mark;
 
+	to->am_id = from->am_id;
+
 	skb_copy_hash(to, from);
 
 #ifdef CONFIG_NET_SCHED
