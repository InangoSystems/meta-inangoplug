From b98f326db35ba6771f313a338fdfd18b8f39aec0 Mon Sep 17 00:00:00 2001
From: Igor Plesser <i.plesser@inango-systems.com>
Date: Mon, 6 Feb 2023 14:42:42 +0200
Subject: [PATCH] Fixed vswitchd crash if an interface has subscriptions from
 more than one MAC.

BugID: 32075
- Added support for deleting all multicast subscriptions from a multicast group regardless of MAC address.
- Fixed multicast subscription timeout values that could be equal to or close to 0.
---
 lib/mcast-snooping.c | 24 +++++++++++++++++++-----
 1 file changed, 19 insertions(+), 5 deletions(-)

diff --git a/lib/mcast-snooping.c b/lib/mcast-snooping.c
index 07910f4de..adfa2f732 100644
--- a/lib/mcast-snooping.c
+++ b/lib/mcast-snooping.c
@@ -453,16 +453,17 @@ mcast_group_delete_bundle(struct mcast_snooping *ms OVS_UNUSED,
     OVS_REQ_WRLOCK(ms->rwlock)
 {
     struct mcast_group_bundle *b;
+    bool flushed = false;
 
     LIST_FOR_EACH (b, bundle_node, &grp->bundle_lru) {
         if (b->port == port && (mac ? eth_addr_equals(*mac, b->mac) : true)) {
             ovs_list_remove(&b->bundle_node);
             dpif_netlink_rtm_del_mcast_grp(b->dpif, b->port_no, &grp->addr, grp->vlan, mac);
             mcast_snooping_flush_group_bundle(ms, b);
-            return true;
+            flushed = true;
         }
     }
-    return false;
+    return flushed;
 }
 
 /* If any bundle has expired, delete it.  Returns the number of deleted
@@ -1088,15 +1089,28 @@ mcast_snooping_wait__(struct mcast_snooping *ms)
         poll_immediate_wake();
     } else {
         struct mcast_group *grp;
-        struct mcast_group_bundle *bundle;
+        struct mcast_group_bundle *bundle, *next_b;
         struct mcast_mrouter_bundle *mrouter;
         long long int mrouter_msec;
         long long int msec = 0;
 
         if (!ovs_list_is_empty(&ms->group_lru)) {
             grp = mcast_group_from_lru_node(ms->group_lru.next);
-            bundle = mcast_group_bundle_from_lru_node(grp->bundle_lru.next);
-            msec = bundle->expires * 1000LL;
+            /*
+             * Finding the first expired bundle
+             */
+            LIST_FOR_EACH_SAFE (bundle, next_b, bundle_node, &grp->bundle_lru) {
+                bundle = mcast_group_bundle_from_lru_node(grp->bundle_lru.next);
+                if(bundle->expires)
+                    break;
+            }
+
+            /*
+             * If a bundle is found, convert seconds to milliseconds
+             * and set the value to msec
+             */
+            if(bundle)
+                msec = bundle->expires * 1000LL;
         }
 
         if (!ovs_list_is_empty(&ms->mrouter_lru)) {
