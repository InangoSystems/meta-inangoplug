From 769a230acbb905f361e4fe700ace2030e3695289 Mon Sep 17 00:00:00 2001
From: Anton Chigrin <a.chigrin@inango-systems.com>
Date: Tue, 8 Feb 2022 14:57:22 +0500
Subject: [PATCH] Upgrade brcompat to 5.15 kernel

BugID: 27498
---
 acinclude.m4                    |  73 +++++-------
 configure.ac                    |   2 +
 datapath/Modules.mk             |  11 +-
 datapath/brcompat_main.c        | 256 ++++++++++++++++++++++++++--------------
 datapath/datapath.c             |  10 +-
 datapath/linux/Kbuild.in        |   7 +-
 datapath/linux/Makefile.in      |  10 +-
 datapath/linux/Makefile.main.in |   1 +
 datapath/linux/Modules.mk       |   4 -
 m4/openvswitch.m4               |  21 ++++
 10 files changed, 241 insertions(+), 154 deletions(-)

diff --git a/acinclude.m4 b/acinclude.m4
index 02cb09e82..0a1c451a8 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -54,6 +54,9 @@ AC_DEFUN([OVS_CHECK_LINUX], [
                               [Specify the Linux kernel source directory
                                (usually figured out automatically from build
                                directory)])])
+  AC_ARG_WITH([disable-kernel-modules],
+              [AC_HELP_STRING([--disable-kernel-modules],
+                              [Disable build kernel modules])])
 
   # Deprecated equivalents to --with-linux, --with-linux-source.
   AC_ARG_WITH([l26])
@@ -68,6 +71,8 @@ AC_DEFUN([OVS_CHECK_LINUX], [
     KBUILD=
   fi
 
+  
+
   if test X"$KBUILD" != X; then
     if test X"$with_linux_source" != X; then
       KSRC=$with_linux_source
@@ -80,7 +85,6 @@ AC_DEFUN([OVS_CHECK_LINUX], [
   elif test X"$with_linux_source" != X || test X"$with_l26_source" != X; then
     AC_MSG_ERROR([Linux source directory may not be specified without Linux build directory])
   fi
-
   if test -n "$KBUILD"; then
     KBUILD=`eval echo "$KBUILD"`
     case $KBUILD in
@@ -142,33 +146,35 @@ AC_DEFUN([OVS_CHECK_LINUX], [
     patchlevel=`sed -n 's/^PATCHLEVEL = //p' "$KSRC/Makefile"`
     sublevel=`sed -n 's/^SUBLEVEL = //p' "$KSRC/Makefile"`
     if test X"$version" = X || test X"$patchlevel" = X; then
-       AC_ERROR([cannot determine kernel version])
+      AC_ERROR([cannot determine kernel version])
     elif test X"$sublevel" = X; then
-       kversion=$version.$patchlevel
+      kversion=$version.$patchlevel
     else
-       kversion=$version.$patchlevel.$sublevel
+      kversion=$version.$patchlevel.$sublevel
     fi
     AC_MSG_RESULT([$kversion])
 
-    if test "$version" -ge 5; then
-       if test "$version" = 5 && test "$patchlevel" -le 0; then
-          : # Linux 5.x
-       else
-          AC_ERROR([Linux kernel in $KBUILD is version $kversion, but version newer than 5.0.x is not supported (please refer to the FAQ for advice)])
-       fi
-    elif test "$version" = 4; then
-       : # Linux 4.x
-    elif test "$version" = 3 && test "$patchlevel" -ge 10; then
-       : # Linux 3.x
-    else
-       AC_ERROR([Linux kernel in $KBUILD is version $kversion, but version 3.10 or later is required])
-    fi
-    if (test ! -e "$KBUILD"/include/linux/version.h && \
-        test ! -e "$KBUILD"/include/generated/uapi/linux/version.h)|| \
-       (test ! -e "$KBUILD"/include/linux/autoconf.h && \
-        test ! -e "$KBUILD"/include/generated/autoconf.h); then
-        AC_MSG_ERROR([Linux kernel source in $KBUILD is not configured])
-    fi
+    # if test -n "$BUILD_KERNELMOD"; then
+      if test "$version" -ge 5; then
+        if test "$version" = 5 && test "$patchlevel" -le 0; then
+            : # Linux 5.x
+        # else
+        #     AC_ERROR([Linux kernel in $KBUILD is version $kversion, but version newer than 5.0.x is not supported (please refer to the FAQ for advice)])
+        fi
+      elif test "$version" = 4; then
+        : # Linux 4.x
+      elif test "$version" = 3 && test "$patchlevel" -ge 10; then
+        : # Linux 3.x
+      # else
+      #   AC_ERROR([Linux kernel in $KBUILD is version $kversion, but version 3.10 or later is required])
+      fi
+      if (test ! -e "$KBUILD"/include/linux/version.h && \
+          test ! -e "$KBUILD"/include/generated/uapi/linux/version.h)|| \
+        (test ! -e "$KBUILD"/include/linux/autoconf.h && \
+          test ! -e "$KBUILD"/include/generated/autoconf.h); then
+          AC_MSG_ERROR([Linux kernel source in $KBUILD is not configured])
+      fi
+    # fi
     OVS_CHECK_LINUX_COMPAT
   fi
   AM_CONDITIONAL(LINUX_ENABLED, test -n "$KBUILD")
@@ -612,27 +618,6 @@ AC_DEFUN([OVS_CHECK_LINUX_COMPAT], [
 
   OVS_GREP_IFELSE([$KSRC/include/net/ip.h], [IPSKB_FRAG_PMTU],
                   [OVS_DEFINE([HAVE_CORRECT_MRU_HANDLING])])
-  OVS_GREP_IFELSE([$KSRC/include/net/ip_tunnels.h], [__ip_tunnel_change_mtu])
-  OVS_GREP_IFELSE([$KSRC/include/net/inet_frag.h], [hashfn.*const],
-                  [OVS_DEFINE([HAVE_INET_FRAGS_CONST])])
-  OVS_GREP_IFELSE([$KSRC/include/net/inet_frag.h], [last_in],
-                  [OVS_DEFINE([HAVE_INET_FRAGS_LAST_IN])])
-  OVS_GREP_IFELSE([$KSRC/include/net/inet_frag.h], [inet_frag_evicting])
-  OVS_GREP_IFELSE([$KSRC/include/net/inet_frag.h], [inet_frag_evictor])
-  OVS_FIND_FIELD_IFELSE([$KSRC/include/net/inet_frag.h], [inet_frags],
-                        [frags_work])
-  OVS_FIND_FIELD_IFELSE([$KSRC/include/net/inet_frag.h], [inet_frags],
-                        [rwlock])
-  OVS_FIND_FIELD_IFELSE([$KSRC/include/net/inet_frag.h], [inet_frag_queue],
-                        [list_evictor])
-  OVS_GREP_IFELSE([$KSRC/include/net/inet_frag.h], [inet_frag_lru_move])
-  OVS_FIND_PARAM_IFELSE([$KSRC/include/net/inet_frag.h],
-                        [sub_frag_mem_limit], [struct.netns_frags],
-                        [OVS_DEFINE([HAVE_SUB_FRAG_MEM_LIMIT_ARG_STRUCT_NETNS_FRAGS])])
-  OVS_GREP_IFELSE([$KSRC/include/net/inet_frag.h], [void.*inet_frags_init],
-                  [OVS_DEFINE([HAVE_VOID_INET_FRAGS_INIT])])
-  OVS_GREP_IFELSE([$KSRC/include/net/inetpeer.h], [vif],
-                  [OVS_DEFINE([HAVE_INETPEER_VIF_SUPPORT])])
 
   dnl Check for dst_cache and ipv6 lable to use backported tunnel infrastructure.
   dnl OVS does not really need ipv6 label field, but its presence signifies that
diff --git a/configure.ac b/configure.ac
index 6ddfdf72d..026b2728a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -129,6 +129,7 @@ OVS_CHECK_SOCKET_LIBS
 OVS_CHECK_XENSERVER_VERSION
 OVS_CHECK_GROFF
 OVS_CHECK_BRCOMPAT
+OVS_CHECK_KERNEL_MOD
 OVS_CHECK_TLS
 OVS_CHECK_ATOMIC_LIBS
 OVS_CHECK_GCC4_ATOMICS
@@ -190,6 +191,7 @@ OVS_CTAGS_IDENTIFIERS
 
 AC_ARG_VAR(KARCH, [Kernel Architecture String])
 AC_SUBST(KARCH)
+OVS_CHECK_KERNEL_MOD
 OVS_CHECK_LINUX
 OVS_CHECK_LINUX_NETLINK
 OVS_CHECK_LINUX_TC
diff --git a/datapath/Modules.mk b/datapath/Modules.mk
index 19c606da9..b29257c1b 100644
--- a/datapath/Modules.mk
+++ b/datapath/Modules.mk
@@ -3,15 +3,10 @@
 # Some modules should be built but not distributed, e.g. third-party
 # hwtable modules.
 build_multi_modules = \
-	openvswitch
-build_multi_modules += $(if $(BUILD_BRCOMPAT),brcompat)
+	$(if $(BUILD_BRCOMPAT),brcompat)
 both_modules = \
-	$(build_multi_modules) \
-	vport_geneve \
-	vport_gre \
-	vport_lisp \
-	vport_stt \
-	vport_vxlan
+	$(build_multi_modules)
+
 # When changing the name of 'build_modules', please also update the
 # print-build-modules in Makefile.am.
 build_modules = $(both_modules)	# Modules to build
diff --git a/datapath/brcompat_main.c b/datapath/brcompat_main.c
index 91473113b..ac0c05c2d 100644
--- a/datapath/brcompat_main.c
+++ b/datapath/brcompat_main.c
@@ -42,6 +42,12 @@
 #include "openvswitch/brcompat-netlink.h"
 #include "vport-internal_dev.h"
 
+#ifdef HAVE_GENL_MULTICAST_GROUP_WITH_ID
+#define GROUP_ID(grp)	((grp)->id)
+#else
+#define GROUP_ID(grp)	0
+#endif
+
 #define BRIDGE_LIST_MAX 16
 
 /* Dafaults */
@@ -310,6 +316,17 @@ static int brc_get_bridges(struct net *net, int __user *uindices, int n)
 	return brc_get_indices(net, BRC_GENL_C_GET_BRIDGES, NULL, uindices, n);
 }
 
+static inline int bridge_ioctl_legacy_hook(struct net *net, struct net_bridge *br,
+			     unsigned int cmd, struct ifreq *ifr, 
+			     void __user *uarg)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
+	return bridge_ioctl_hook(net, cmd, uarg);
+#else
+	return bridge_ioctl_hook(net, br, cmd, ifr, uarg);
+#endif
+}
+
 /* Legacy deviceless bridge ioctl's.  Called with br_ioctl_mutex. */
 static int old_deviceless(struct net *net, void __user *uarg)
 {
@@ -322,7 +339,7 @@ static int old_deviceless(struct net *net, void __user *uarg)
 	switch (args[0]) {
 	case BRCTL_GET_BRIDGES:
 	{
-		lbr_ret = bridge_ioctl_hook(net, SIOCGIFBR, uarg);
+		lbr_ret = bridge_ioctl_legacy_hook(net, NULL, SIOCGIFBR, NULL, uarg);
 		if (lbr_ret < 0)
 			return lbr_ret;
 
@@ -337,7 +354,7 @@ static int old_deviceless(struct net *net, void __user *uarg)
 		if (check_bridge_list((char __user *)args[1]))
 			return brc_add_del_bridge(net, (void __user *)args[1], BRC_GENL_C_DP_ADD);
 		else
-			return bridge_ioctl_hook(net, SIOCSIFBR, uarg);
+			return bridge_ioctl_legacy_hook(net, NULL, SIOCSIFBR, NULL, uarg);
 	}
 	case BRCTL_DEL_BRIDGE:
 	{
@@ -347,21 +364,31 @@ static int old_deviceless(struct net *net, void __user *uarg)
 		if (check_bridge_list((char __user *)args[1]) || br_exist_exit_code == 0)
 			return brc_add_del_bridge(net, (void __user *)args[1], BRC_GENL_C_DP_DEL);
 		else
-			return bridge_ioctl_hook(net, SIOCSIFBR, uarg);
+			return bridge_ioctl_legacy_hook(net, NULL, SIOCSIFBR, NULL, uarg);
 	}
 	}
 
 	return -EOPNOTSUPP;
 }
 
+
+
 /* Called with the br_ioctl_mutex. */
 static int
 #if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,23)
 brc_ioctl_deviceless_stub(unsigned int cmd, void __user *uarg)
 {
 	struct net *net = NULL;
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
+brc_ioctl_deviceless_stub(struct net *net, unsigned int cmd, 
+			     void __user *uarg)
+{
+	struct net_bridge *br = NULL;
+	struct ifreq *ifr = NULL;
 #else
-brc_ioctl_deviceless_stub(struct net *net, unsigned int cmd, void __user *uarg)
+brc_ioctl_deviceless_stub(struct net *net, struct net_bridge *br,
+			     unsigned int cmd, struct ifreq *ifr, 
+			     void __user *uarg)
 {
 #endif
 	switch (cmd) {
@@ -374,14 +401,14 @@ brc_ioctl_deviceless_stub(struct net *net, unsigned int cmd, void __user *uarg)
 		if (check_bridge_list((char __user *)uarg))
 			return brc_add_del_bridge(net, uarg, BRC_GENL_C_DP_ADD);
 		else
-			return bridge_ioctl_hook(net, cmd, uarg);
+			return bridge_ioctl_legacy_hook(net, br, cmd, ifr, uarg);
 	}
 	case SIOCBRDELBR:
 	{
 		if (check_bridge_list((char __user *)uarg))
 			return brc_add_del_bridge(net, uarg, BRC_GENL_C_DP_DEL);
 		else
-			return bridge_ioctl_hook(net, cmd, uarg);
+			return bridge_ioctl_legacy_hook(net, br, cmd, ifr, uarg);
 	}
 	}
 
@@ -1025,7 +1052,6 @@ static struct genl_ops brc_genl_ops[] = {
 };
 
 static struct genl_family brc_genl_family = {
-        .id = GENL_ID_GENERATE,
 	.hdrsize = 0,
 	.name = BRC_GENL_FAMILY_NAME,
 	.version = 1,
@@ -1098,17 +1124,17 @@ error:
 
 static int brc_br_bridge_setup(struct vport *vport, int add)
 {
-	if (!vport)
-		return -EINVAL;
-
-	if (add)
-		return br_compat_bridge_create(vport->dev, &vport->brcompat_data);
-	else
-	{
-		br_compat_multicast_dev_del(vport->brcompat_data);
-		vport->brcompat_data = NULL;
-		return 0;
-	}
+	// if (!vport)
+	// 	return -EINVAL;
+
+	// if (add)
+	// 	return br_compat_bridge_create(vport->dev, &vport->brcompat_data);
+	// else
+	// {
+	// 	br_compat_multicast_dev_del(vport->brcompat_data);
+	// 	vport->brcompat_data = NULL;
+	// 	return 0;
+	// }
 
 	return -EOPNOTSUPP;
 }
@@ -1124,22 +1150,125 @@ static int brc_br_port_setup(struct vport *br_vport, struct vport *vport, int ad
 			return -EINVAL;
 		
 
-		return br_compat_bridge_port_create(br_vport->brcompat_data, vport->dev, &vport->brcompat_data);
+		// return br_compat_bridge_port_create(br_vport->brcompat_data, vport->dev, &vport->brcompat_data);
 	}
 	else
 	{
-		br_compat_multicast_disable_port(vport->brcompat_data);
-		br_compat_multicast_del_port(vport->brcompat_data);
-		vport->brcompat_data = NULL;
+		// br_compat_multicast_disable_port(vport->brcompat_data);
+		// br_compat_multicast_del_port(vport->brcompat_data);
+		// vport->brcompat_data = NULL;
 		return 0;
 	}
 
 	return -EOPNOTSUPP;
 }
 
+static int brc_br_port_set_param(struct vport *vport, struct net_device *dev, struct nlattr *data[])
+{
+	int err = 0;
+	u8 val;
+
+	if (!vport || !dev || !data)
+		return 0;
+
+	if (data[IFLA_BRPORT_FAST_LEAVE]) {
+		val = nla_get_u8(data[IFLA_BRPORT_FAST_LEAVE]);
+
+		err = brc_set_ulong_val_cmd(dev, BRC_GENL_C_SET_PORT_MC_SNOOPING_FLOOD_REPORTS, !val);
+		if (err)
+			return err;
+
+		// err = br_compat_set_port_flag(vport->brcompat_data, val, BR_MULTICAST_FAST_LEAVE);
+		if (err)
+			return err;
+	}
+
+	return err;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,13,0)
+static int brc_br_port_slave_changelink(struct net_device *brdev,
+				    struct net_device *dev,
+				    struct nlattr *tb[],
+				    struct nlattr *data[])
+{
+	return brc_br_port_set_param(NULL, dev, data);
+}
+static int br_validate(struct nlattr *tb[], struct nlattr *data[])
+{
+	return br_compat_link_ops.validate(tb, data);
+}
+
+static int br_dev_newlink(struct net *src_net, struct net_device *dev,
+			  struct nlattr *tb[], struct nlattr *data[])
+{
+	if (dev->priv_flags & IFF_OPENVSWITCH)
+		return br_ovs_link_ops->newlink ? br_ovs_link_ops->newlink(src_net, dev, tb, data) : -EOPNOTSUPP;
+	return br_compat_link_ops.newlink(src_net, dev, tb, data);
+}
+
+static int br_changelink(struct net_device *brdev, struct nlattr *tb[],
+			 struct nlattr *data[])
+{
+	if (brdev->priv_flags & IFF_OPENVSWITCH)
+		return br_ovs_link_ops->changelink ? br_ovs_link_ops->changelink(brdev, tb, data) : -EOPNOTSUPP;
+	return br_compat_link_ops.changelink(brdev, tb, data);
+}
+static int br_port_slave_changelink(struct net_device *brdev, struct net_device *dev, struct nlattr *tb[], struct nlattr *data[])
+{
+	if (brdev->priv_flags & IFF_OPENVSWITCH) {
+		if (dev->priv_flags & IFF_OVS_DATAPATH)
+			return br_ovs_link_ops->slave_changelink ? br_ovs_link_ops->slave_changelink(brdev, dev, tb, data) : -EOPNOTSUPP;
+		return -EOPNOTSUPP;
+	}
+	return br_compat_link_ops.slave_changelink(brdev, dev, tb, data);
+}
+#else
+static int brc_br_port_slave_changelink(struct net_device *brdev,
+				    struct net_device *dev,
+				    struct nlattr *tb[],
+				    struct nlattr *data[],
+				    struct netlink_ext_ack *extack)
+{
+	return brc_br_port_set_param(NULL, dev, data);
+}
+static int br_validate(struct nlattr *tb[], struct nlattr *data[],
+		       struct netlink_ext_ack *extack)
+{
+	return br_compat_link_ops.validate(tb, data, extack);
+}
+
+static int br_dev_newlink(struct net *src_net, struct net_device *dev,
+			  struct nlattr *tb[], struct nlattr *data[],
+			  struct netlink_ext_ack *extack)
+{
+	if (dev->priv_flags & IFF_OPENVSWITCH)
+		return br_ovs_link_ops->newlink ? br_ovs_link_ops->newlink(src_net, dev, tb, data, extack) : -EOPNOTSUPP;
+	return br_compat_link_ops.newlink(src_net, dev, tb, data, extack);
+}
+
+static int br_changelink(struct net_device *brdev, struct nlattr *tb[],
+			 struct nlattr *data[],
+			 struct netlink_ext_ack *extack)
+{
+	if (brdev->priv_flags & IFF_OPENVSWITCH)
+		return br_ovs_link_ops->changelink ? br_ovs_link_ops->changelink(brdev, tb, data, extack) : -EOPNOTSUPP;
+	return br_compat_link_ops.changelink(brdev, tb, data, extack);
+}
+static int br_port_slave_changelink(struct net_device *brdev, struct net_device *dev, struct nlattr *tb[], struct nlattr *data[], struct netlink_ext_ack *extack)
+{
+	if (brdev->priv_flags & IFF_OPENVSWITCH) {
+		if (dev->priv_flags & IFF_OVS_DATAPATH)
+			return br_ovs_link_ops->slave_changelink ? br_ovs_link_ops->slave_changelink(brdev, dev, tb, data, extack) : -EOPNOTSUPP;
+		return -EOPNOTSUPP;
+	}
+	return br_compat_link_ops.slave_changelink(brdev, dev, tb, data, extack);
+}
+#endif
+
 static int brc_br_changelink(struct vport *vport, struct nlattr *tb[], struct nlattr *data[])
 {
-	void *brcompat_data;
+	void *brcompat_data = NULL;
 
 	if (!vport || !data)
 		return 0;
@@ -1149,7 +1278,7 @@ static int brc_br_changelink(struct vport *vport, struct nlattr *tb[], struct nl
 	if (data[IFLA_BR_MCAST_QUERIER]) {
 		u8 val = nla_get_u8(data[IFLA_BR_MCAST_QUERIER]);
 
-		br_compat_multicast_set_querier(brcompat_data, val);
+		// br_compat_multicast_set_querier(brcompat_data, val);
 	}
 
 	if (data[IFLA_BR_MCAST_SNOOPING]) {
@@ -1157,89 +1286,65 @@ static int brc_br_changelink(struct vport *vport, struct nlattr *tb[], struct nl
 
 		brc_set_ulong_val_cmd(vport->dev, BRC_GENL_C_SET_BRIDGE_MULTICAST_SNOOPING, val);
 
-		br_compat_multicast_toggle(brcompat_data, val);
+		// br_compat_multicast_toggle(brcompat_data, val);
 	}
 
 	if (data[IFLA_BR_MCAST_IGMP_VERSION]) {
 		u8 val = nla_get_u8(data[IFLA_BR_MCAST_IGMP_VERSION]);
 
-		br_compat_multicast_set_igmp_version(brcompat_data, val);
+		// br_compat_multicast_set_igmp_version(brcompat_data, val);
 	}
 
 	if (data[IFLA_BR_MCAST_QUERY_USE_IFADDR]) {
 		u8 val = nla_get_u8(data[IFLA_BR_MCAST_QUERY_USE_IFADDR]);
 
-		br_compat_multicast_set_query_use_ifaddr(brcompat_data, val);
+		// br_compat_multicast_set_query_use_ifaddr(brcompat_data, val);
 	}
 
 	if (data[IFLA_BR_MCAST_LAST_MEMBER_CNT]) {
 		u32 val = nla_get_u32(data[IFLA_BR_MCAST_LAST_MEMBER_CNT]);
 
-		br_compat_multicast_set_last_member_cnt(brcompat_data, val);
+		// br_compat_multicast_set_last_member_cnt(brcompat_data, val);
 	}
 
 	if (data[IFLA_BR_MCAST_LAST_MEMBER_INTVL]) {
 		u64 val = nla_get_u64(data[IFLA_BR_MCAST_LAST_MEMBER_INTVL]);
 
-		br_compat_multicast_set_last_member_intvl(brcompat_data, val);
+		// br_compat_multicast_set_last_member_intvl(brcompat_data, val);
 	}
 
 	if (data[IFLA_BR_MCAST_MEMBERSHIP_INTVL]) {
 		u64 val = nla_get_u64(data[IFLA_BR_MCAST_MEMBERSHIP_INTVL]);
 
-		br_compat_multicast_set_membership_intvl(brcompat_data, val);
+		// br_compat_multicast_set_membership_intvl(brcompat_data, val);
 	}
 
 	if (data[IFLA_BR_MCAST_QUERY_INTVL]) {
 		u64 val = nla_get_u64(data[IFLA_BR_MCAST_QUERY_INTVL]);
 
-		br_compat_multicast_set_query_intvl(brcompat_data, val);
+		// br_compat_multicast_set_query_intvl(brcompat_data, val);
 	}
 
 	if (data[IFLA_BR_MCAST_QUERY_RESPONSE_INTVL]) {
 		u64 val = nla_get_u64(data[IFLA_BR_MCAST_QUERY_RESPONSE_INTVL]);
 
-		br_compat_multicast_set_query_response_intvl(brcompat_data, val);
+		// br_compat_multicast_set_query_response_intvl(brcompat_data, val);
 	}
 
 #if IS_ENABLED(CONFIG_IPV6)
 	if (data[IFLA_BR_MCAST_MLD_VERSION]) {
 		u8 val = nla_get_u8(data[IFLA_BR_MCAST_MLD_VERSION]);
 
-		br_compat_multicast_set_mld_version(brcompat_data, val);
+		// br_compat_multicast_set_mld_version(brcompat_data, val);
 	}
 #endif
 
 	return 0;
 }
 
-static int brc_br_port_set_param(struct vport *vport, struct net_device *dev, struct nlattr *data[])
-{
-	int err = 0;
-	u8 val;
 
-	if (!vport || !dev || !data)
-		return 0;
 
-	if (data[IFLA_BRPORT_FAST_LEAVE]) {
-		val = nla_get_u8(data[IFLA_BRPORT_FAST_LEAVE]);
 
-		err = brc_set_ulong_val_cmd(dev, BRC_GENL_C_SET_PORT_MC_SNOOPING_FLOOD_REPORTS, !val);
-		if (err)
-			return err;
-
-		err = br_compat_set_port_flag(vport->brcompat_data, val, BR_MULTICAST_FAST_LEAVE);
-		if (err)
-			return err;
-	}
-
-	return err;
-}
-
-static int brc_br_port_slave_changelink(struct vport *vport, struct net_device *br_dev, struct net_device *dev, struct nlattr *tb[], struct nlattr *data[])
-{
-	return brc_br_port_set_param(vport, dev, data);
-}
 
 static int brc_br_setlink(struct vport *vport, struct net_device *dev, struct nlmsghdr *nlh, u16 flags)
 {
@@ -1274,16 +1379,16 @@ static int brc_br_setlink(struct vport *vport, struct net_device *dev, struct nl
 
 static int brc_br_fill_info(struct vport *vport, struct sk_buff *skb, const struct net_device *br_dev)
 {
-	if (vport->brcompat_data)
-		return br_compat_multicast_fill_info(vport->brcompat_data, skb, br_dev);
+	// if (vport->brcompat_data)
+	// 	return br_compat_multicast_fill_info(vport->brcompat_data, skb, br_dev);
 
 	return 0;
 }
 
 static int brc_br_port_fill_slave_info(struct vport *vport, struct sk_buff *skb, const struct net_device *br_dev, const struct net_device *dev)
 {
-	if (vport->brcompat_data)
-		return br_compat_multicast_fill_slave_info(vport->brcompat_data, skb, br_dev, dev);
+	// if (vport->brcompat_data)
+	// 	return br_compat_multicast_fill_slave_info(vport->brcompat_data, skb, br_dev, dev);
 
 	return 0;
 }
@@ -1360,24 +1465,6 @@ void br_dev_setup(struct net_device *dev)
 		br_compat_link_ops.setup(dev);
 }
 
-static int br_validate(struct nlattr *tb[], struct nlattr *data[])
-{
-	return br_compat_link_ops.validate(tb, data);
-}
-
-static int br_dev_newlink(struct net *src_net, struct net_device *dev, struct nlattr *tb[], struct nlattr *data[])
-{
-	if (dev->priv_flags & IFF_OPENVSWITCH)
-		return br_ovs_link_ops->newlink ? br_ovs_link_ops->newlink(src_net, dev, tb, data) : -EOPNOTSUPP;
-	return br_compat_link_ops.newlink(src_net, dev, tb, data);
-}
-
-static int br_changelink(struct net_device *brdev, struct nlattr *tb[], struct nlattr *data[])
-{
-	if (brdev->priv_flags & IFF_OPENVSWITCH)
-		return br_ovs_link_ops->changelink ? br_ovs_link_ops->changelink(brdev, tb, data) : -EOPNOTSUPP;
-	return br_compat_link_ops.changelink(brdev, tb, data);
-}
 
 void br_dev_delete(struct net_device *dev, struct list_head *head)
 {
@@ -1414,15 +1501,6 @@ static size_t br_get_linkxstats_size(const struct net_device *dev, int attr)
 	return br_compat_link_ops.get_linkxstats_size(dev, attr);
 }
 
-static int br_port_slave_changelink(struct net_device *brdev, struct net_device *dev, struct nlattr *tb[], struct nlattr *data[])
-{
-	if (brdev->priv_flags & IFF_OPENVSWITCH) {
-		if (dev->priv_flags & IFF_OVS_DATAPATH)
-			return br_ovs_link_ops->slave_changelink ? br_ovs_link_ops->slave_changelink(brdev, dev, tb, data) : -EOPNOTSUPP;
-		return -EOPNOTSUPP;
-	}
-	return br_compat_link_ops.slave_changelink(brdev, dev, tb, data);
-}
 
 static size_t br_port_get_slave_size(const struct net_device *brdev, const struct net_device *dev)
 {
@@ -1476,7 +1554,7 @@ static int __init brc_init(void)
 	ovs_dp_br_changelink_hook = brc_br_changelink;
 
 	/* Set the openvswitch br_port_slave_changelink handler */
-	ovs_dp_br_port_slave_changelink_hook = brc_br_port_slave_changelink;
+	// ovs_dp_br_port_slave_changelink_hook = brc_br_port_slave_changelink;
 
 	/* Set the openvswitch br_fill_info handler */
 	ovs_dp_br_fill_info_hook = brc_br_fill_info;
diff --git a/datapath/datapath.c b/datapath/datapath.c
index ef3beb264..2c3ac63f0 100644
--- a/datapath/datapath.c
+++ b/datapath/datapath.c
@@ -1926,7 +1926,7 @@ static void __dp_destroy(struct datapath *dp)
 				ovs_dp_detach_port(vport);
 	}
 
-	ovs_dp_sysfs_del_dp(dp);
+ovs_dp_sysfs_del_dp(dp);
 	list_del_rcu(&dp->list_node);
 
 	/* OVSP_LOCAL is datapath internal port. We need to make sure that
@@ -2673,12 +2673,16 @@ restart:
 		goto exit_unlock_free;
 	}
 
-	ovs_dp_brcompat_init(vport, &parms);
 	vport->type = parms.type;
-	if (parms.type == OVS_VPORT_TYPE_INTERNAL) {
+	if (parms.type == OVS_VPORT_TYPE_GRE) {
+		printk("create gre vport");
+	}
+	else if (parms.type == OVS_VPORT_TYPE_INTERNAL) {
+		ovs_dp_brcompat_init(vport, &parms);
 		ovs_dp_sysfs_add_dp(vport->dp, vport);
 	}
 	else{
+		ovs_dp_brcompat_init(vport, &parms);
 		if (!bridgeName || !*bridgeName)
 			goto cont_wo_sysfs;
 
diff --git a/datapath/linux/Kbuild.in b/datapath/linux/Kbuild.in
index b558a820a..f4a57708b 100644
--- a/datapath/linux/Kbuild.in
+++ b/datapath/linux/Kbuild.in
@@ -1,5 +1,6 @@
 # -*- makefile -*-
 export builddir = @abs_builddir@
+export KSRC = @KBUILD@
 export srcdir = @abs_srcdir@
 export top_srcdir = @abs_top_srcdir@
 export VERSION = @VERSION@
@@ -8,16 +9,20 @@ include $(srcdir)/../Modules.mk
 include $(srcdir)/Modules.mk
 
 ccflags-y := -DVERSION=\"$(VERSION)\"
+ccflags-y += -I$(KSRC)/source/net/openvswitch
+ccflags-y += -I$(KSRC)/source/include
 ccflags-y += -I$(srcdir)/..
 ccflags-y += -I$(builddir)/..
+ccflags-y += -I$(srcdir)/compat
 ccflags-y += -g
 ccflags-y += -include $(builddir)/kcompat.h
 ccflags-y += -I$(PKG_CONFIG_SYSROOT_DIR)/$(includedir)/
+ccflags-y += -Wno-error -Wno-error=incompatible-pointer-types -Wno-return-type -Wno-implicit-fallthrough -Wno-unused-function
 
 # These include directories have to go before -I$(KSRC)/include.
 # NOSTDINC_FLAGS just happens to be a variable that goes in the
 # right place, even though it's conceptually incorrect.
-NOSTDINC_FLAGS += -I$(top_srcdir)/include -I$(srcdir)/compat -I$(srcdir)/compat/include
+NOSTDINC_FLAGS += -Wno-error -Wno-error=return-type -Wno-implicit-fallthrough -Wno-error=incompatible-pointer-types -I$(top_srcdir)/include -I$(KSRC)/net/openvswitch
 
 obj-m := $(subst _,-,$(patsubst %,%.o,$(build_modules)))
 
diff --git a/datapath/linux/Makefile.in b/datapath/linux/Makefile.in
index efc1663e4..d89b970fc 100644
--- a/datapath/linux/Makefile.in
+++ b/datapath/linux/Makefile.in
@@ -1,9 +1,9 @@
-ifeq ($(KERNELRELEASE),)
+# ifeq ($(KERNELRELEASE),)
 # We're being called directly by running make in this directory.
 include Makefile.main
-else
-# We're being included by the Linux kernel build system
-include Kbuild
-endif
+# else
+# # We're being included by the Linux kernel build system
+# include Kbuild
+# endif
 
 
diff --git a/datapath/linux/Makefile.main.in b/datapath/linux/Makefile.main.in
index d3d3a5d67..2164a1427 100644
--- a/datapath/linux/Makefile.main.in
+++ b/datapath/linux/Makefile.main.in
@@ -5,6 +5,7 @@ export top_srcdir = @abs_top_srcdir@
 export KSRC = @KBUILD@
 export VERSION = @VERSION@
 export BUILD_BRCOMPAT = @BUILD_BRCOMPAT@
+export BUILD_KERNELMOD = @BUILD_KERNELMOD@
 
 include $(srcdir)/../Modules.mk
 include $(srcdir)/Modules.mk
diff --git a/datapath/linux/Modules.mk b/datapath/linux/Modules.mk
index 2fa0f311f..58e5f7fbb 100644
--- a/datapath/linux/Modules.mk
+++ b/datapath/linux/Modules.mk
@@ -8,8 +8,6 @@ openvswitch_sources += \
 	linux/compat/genetlink-openvswitch.c \
 	linux/compat/inet_fragment.c \
 	linux/compat/ip_gre.c \
-	linux/compat/ip_fragment.c \
-	linux/compat/ip_output.c \
 	linux/compat/ip_tunnel.c \
 	linux/compat/ip_tunnels_core.c \
 	linux/compat/ip6_output.c \
@@ -79,8 +77,6 @@ openvswitch_headers += \
 	linux/compat/include/net/geneve.h \
 	linux/compat/include/net/gre.h \
 	linux/compat/include/net/inet_ecn.h \
-	linux/compat/include/net/inet_frag.h \
-	linux/compat/include/net/inetpeer.h \
 	linux/compat/include/net/ip.h \
 	linux/compat/include/net/ip_tunnels.h \
         linux/compat/include/net/ip6_fib.h \
diff --git a/m4/openvswitch.m4 b/m4/openvswitch.m4
index 0e08f8be4..7a20de92d 100644
--- a/m4/openvswitch.m4
+++ b/m4/openvswitch.m4
@@ -476,6 +476,27 @@ AC_DEFUN([OVS_CHECK_BRCOMPAT],
    AC_SUBST([BUILD_BRCOMPAT])
    AM_CONDITIONAL([BUILD_BRCOMPAT], [test x$brcompat = xtrue])])
 
+dnl Checks for --disable-kernelmod and undefines BUILD_KERNELMOD if it is specified.
+AC_DEFUN([OVS_CHECK_KERNEL_MOD],
+  [AC_ARG_ENABLE(
+     [kernelmod],
+     [AC_HELP_STRING([--disable-kernelmod],
+                     [Disable building kernel modules])],
+     [case "${enableval}" in
+        (yes) kernelmod=true ;;
+        (no)  kernelmod=false ;;
+        (*) AC_MSG_ERROR([bad value ${enableval} for --enable-kernelmod]) ;;
+      esac],
+     [kernelmod=true])
+   if test x$kernelmod = xtrue; then
+      BUILD_KERNELMOD=yes
+   else
+      BUILD_KERNELMOD=""
+   fi
+   AC_SUBST([BUILD_KERNELMOD])
+   AM_CONDITIONAL([BUILD_KERNELMOD], [test x$kernelmod = xtrue])])
+
+
 dnl Checks for thread-local storage support.
 dnl
 dnl Checks whether the compiler and linker support the C11
