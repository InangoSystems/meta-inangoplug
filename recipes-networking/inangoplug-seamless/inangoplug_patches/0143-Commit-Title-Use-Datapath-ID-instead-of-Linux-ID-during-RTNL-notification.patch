From 9e387bfd15ee226fecee414a00be7824dec7700a Mon Sep 17 00:00:00 2001
From: Anton Bilohai <a.bilohai@inango-systems.com>
Date: Tue, 26 Apr 2022 22:04:51 +0300
Subject: [PATCH] Commit Title: Use Datapath ID instead of Linux ID during RTNL
 notification

BugID: 27194
Bug Fixed(y/N[blankN]): n
CodeReviewId: 0
Description:
    - Usage of Linux indexes in userspace-kernelspace communication
    inside of OVS is not common. Usually, OVS or Datapath indexes are
    used.
    - Use OVS Datapath indexes during process of Linux notification
    about new/del neighbors (RTNL_NEIGH)
---
 datapath/datapath.c          | 55 ++++++++++++++++++++++++++------------------
 lib/automake.mk              |  3 +++
 lib/dpif-netlink.c           | 26 ++++++++++++++++-----
 lib/dpif-netlink.h           |  5 ++--
 lib/mac-learning.c           |  8 ++++++-
 lib/mac-learning.h           |  2 +-
 ofproto/ofproto-dpif-xlate.c | 17 +++++++-------
 ofproto/ofproto-dpif.c       |  9 ++++++++
 ofproto/ofproto-dpif.h       |  1 +
 9 files changed, 85 insertions(+), 41 deletions(-)

diff --git a/datapath/datapath.c b/datapath/datapath.c
index 6dbb58a4d..800ba3a6a 100644
--- a/datapath/datapath.c
+++ b/datapath/datapath.c
@@ -2095,10 +2095,10 @@ static int ovs_vport_cmd_newneigh(struct sk_buff *skbn, struct genl_info *info)
     struct ndmsg *ndm;
     struct sk_buff *skb;
     struct net *net;
-    struct net_device *dev;
     struct ovs_header *ovs_header = info->userhdr;
-    int ifindex = ovs_header->dp_ifindex;
     u8 mac_addr[ETH_ALEN];
+    int err;
+    struct vport *input_vport;
 
     if (a[OVS_VPORT_ATTR_MAC]) {
         struct nlattr *mac_attr = a[OVS_VPORT_ATTR_MAC];
@@ -2106,6 +2106,15 @@ static int ovs_vport_cmd_newneigh(struct sk_buff *skbn, struct genl_info *info)
     } else {
           goto error;
     }
+    net = sock_net(skbn->sk);
+
+    rcu_read_lock();
+    input_vport = lookup_vport(net, ovs_header, info->attrs);
+    rcu_read_unlock();
+
+    err = PTR_ERR(input_vport);
+    if (IS_ERR(input_vport))
+        return err;
 
     skb = nlmsg_new(rtnl_fdb_nlmsg_size(), GFP_ATOMIC);
     nlh = nlmsg_put(skb, 0, 0,  RTM_NEWNEIGH, sizeof(*ndm), 0);
@@ -2116,27 +2125,23 @@ static int ovs_vport_cmd_newneigh(struct sk_buff *skbn, struct genl_info *info)
     ndm->ndm_pad2    = 0;
     ndm->ndm_flags   = NTF_SELF;
     ndm->ndm_type    = 0;
-    ndm->ndm_ifindex = ifindex;
+    ndm->ndm_ifindex = input_vport->dev->ifindex;
     ndm->ndm_state   = NUD_REACHABLE;
 
-    dev = dev_get_by_index(&init_net, ifindex);
-
-    if (dev == NULL)
-	    return -ENODEV;
-
     if (nla_put(skb, NDA_LLADDR, ETH_ALEN, &mac_addr))
         goto nla_put_failure;
 
     nlmsg_end(skb, nlh);
-    net = dev_net(dev);
     rtnl_notify(skb, net, 0, RTNLGRP_NEIGH, NULL, GFP_ATOMIC);
-	dev_put(dev);
+    dev_put(input_vport->dev);
+
     return 0;
 
 nla_put_failure:
     nlmsg_cancel(skb, nlh);
-	dev_put(dev);
+
 error:
+    dev_put(input_vport->dev);
     return -EMSGSIZE;
 }
 
@@ -2147,10 +2152,10 @@ static int ovs_vport_cmd_delneigh(struct sk_buff *skbn, struct genl_info *info)
     struct ndmsg *ndm;
     struct sk_buff *skb;
     struct net *net;
-    struct net_device *dev;
     struct ovs_header *ovs_header = info->userhdr;
-    int ifindex = ovs_header->dp_ifindex;
     u8 mac_addr[ETH_ALEN];
+    int err;
+    struct vport *input_vport;
 
     if (a[OVS_VPORT_ATTR_MAC]) {
         struct nlattr *mac_attr = a[OVS_VPORT_ATTR_MAC];
@@ -2158,6 +2163,15 @@ static int ovs_vport_cmd_delneigh(struct sk_buff *skbn, struct genl_info *info)
     } else {
           goto error;
     }
+    net = sock_net(skbn->sk);
+
+    rcu_read_lock();
+    input_vport = lookup_vport(net, ovs_header, a);
+    rcu_read_unlock();
+
+    err = PTR_ERR(input_vport);
+    if (IS_ERR(input_vport))
+        return err;
 
     skb = nlmsg_new(rtnl_fdb_nlmsg_size(), GFP_ATOMIC);
     nlh = nlmsg_put(skb, 0, 0,  RTM_DELNEIGH, sizeof(*ndm), 0);
@@ -2168,28 +2182,23 @@ static int ovs_vport_cmd_delneigh(struct sk_buff *skbn, struct genl_info *info)
     ndm->ndm_pad2    = 0;
     ndm->ndm_flags   = NTF_SELF;
     ndm->ndm_type    = 0;
-    ndm->ndm_ifindex = ifindex;
+    ndm->ndm_ifindex = input_vport->dev->ifindex;
     ndm->ndm_state   = NUD_FAILED;
 
-    dev = dev_get_by_index(&init_net, ifindex);
-
-    if (dev == NULL)
-	    return -ENODEV;
-
     if (nla_put(skb, NDA_LLADDR, ETH_ALEN, &mac_addr))
         goto nla_put_failure;
 
     nlmsg_end(skb, nlh);
-    net = dev_net(dev);
     rtnl_notify(skb, net, 0, RTNLGRP_NEIGH, NULL, GFP_ATOMIC);
-	dev_put(dev);
+    dev_put(input_vport->dev);
 
     return 0;
 
 nla_put_failure:
     nlmsg_cancel(skb, nlh);
-	dev_put(dev);
+
 error:
+    dev_put(input_vport->dev);
     return -EMSGSIZE;
 }
 
@@ -3222,7 +3231,7 @@ static int __init dp_init(void)
 
 	err = dp_register_genl();
 	if (err < 0)
-		goto error_unreg_netdev;	
+        goto error_unreg_netdev;
 
 	pp_am_set_am_id_by_ufid_callback(notify_am_id);
 
diff --git a/lib/automake.mk b/lib/automake.mk
index 95925b57c..4eae0cefc 100644
--- a/lib/automake.mk
+++ b/lib/automake.mk
@@ -338,6 +338,9 @@ lib_libopenvswitch_la_SOURCES = \
 	lib/lldp/lldpd-structs.c \
 	lib/lldp/lldpd-structs.h
 
+lib_libopenvswitch_la_LIBADD += \
+	ofproto/libofproto.la
+
 if WIN32
 lib_libopenvswitch_la_SOURCES += \
 	lib/daemon-windows.c \
diff --git a/lib/dpif-netlink.c b/lib/dpif-netlink.c
index a9003245d..be964496e 100644
--- a/lib/dpif-netlink.c
+++ b/lib/dpif-netlink.c
@@ -763,6 +763,15 @@ get_vport_type(const struct dpif_netlink_vport *vport)
     return "unknown";
 }
 
+int
+dpif_to_dp_ifindex(void *dpif)
+{
+    struct dpif_netlink *dpif_nl;
+
+    dpif_nl = dpif_netlink_cast((struct dpif*) dpif);
+    return dpif_nl->dp_ifindex;
+}
+
 enum ovs_vport_type
 netdev_to_ovs_vport_type(const char *type)
 {
@@ -4314,13 +4323,14 @@ dpif_netlink_vport_get(const char *name, struct dpif_netlink_vport *reply,
 }
 
 static int
-dpif_netlink_mac_send(int ifindex, const struct eth_addr src_mac, uint8_t cmd)
+dpif_netlink_mac_send(odp_port_t odp_index, int dp_ifindex, const struct eth_addr src_mac, uint8_t cmd)
 {
     struct dpif_netlink_vport request;
 
     dpif_netlink_vport_init(&request);
     request.cmd = cmd;
-    request.dp_ifindex = ifindex;
+    request.port_no = odp_index;
+    request.dp_ifindex = dp_ifindex;
 
     memcpy(request.ea, src_mac.ea, sizeof(src_mac.ea));
 
@@ -4328,11 +4338,13 @@ dpif_netlink_mac_send(int ifindex, const struct eth_addr src_mac, uint8_t cmd)
 }
 
 int
-dpif_netlink_rtm_newneigh(int ifindex, const struct eth_addr src_mac)
+dpif_netlink_rtm_newneigh(odp_port_t odp_index, int dp_ifindex, const struct eth_addr src_mac)
 {
     int error;
 
-    error = dpif_netlink_mac_send(ifindex, src_mac, OVS_VPORT_CMD_NEWNEIGH);
+    VLOG_DBG("Sending NEWNEIGH odp: %u, dp_ifindex: %d,MAC:%02x:%02x:%02x:%02x:%02x:%02x \n",
+            odp_index, dp_ifindex, src_mac.ea[0], src_mac.ea[1],src_mac.ea[2],src_mac.ea[3],src_mac.ea[4],src_mac.ea[5]);
+    error = dpif_netlink_mac_send(odp_index, dp_ifindex, src_mac, OVS_VPORT_CMD_NEWNEIGH);
 
     if (!error) {
         return -1;
@@ -4342,11 +4354,13 @@ dpif_netlink_rtm_newneigh(int ifindex, const struct eth_addr src_mac)
 }
 
 int
-dpif_netlink_rtm_delneigh(int ifindex, const struct eth_addr src_mac)
+dpif_netlink_rtm_delneigh(odp_port_t odp_index, int dp_ifindex, const struct eth_addr src_mac)
 {
     int error;
 
-    error = dpif_netlink_mac_send(ifindex, src_mac, OVS_VPORT_CMD_DELNEIGH);
+    VLOG_DBG("Sending DELNEIGH odp: %u, dp_ifindex: %d, MAC:%02x:%02x:%02x:%02x:%02x:%02x \n",
+            odp_index, dp_ifindex, src_mac.ea[0], src_mac.ea[1],src_mac.ea[2],src_mac.ea[3],src_mac.ea[4],src_mac.ea[5]);
+    error = dpif_netlink_mac_send(odp_index, dp_ifindex, src_mac, OVS_VPORT_CMD_DELNEIGH);
 
     if (!error) {
         return -1;
diff --git a/lib/dpif-netlink.h b/lib/dpif-netlink.h
index adeb58b7d..31f704743 100644
--- a/lib/dpif-netlink.h
+++ b/lib/dpif-netlink.h
@@ -63,8 +63,8 @@ int dpif_netlink_vport_transact(const struct dpif_netlink_vport *request,
 int dpif_netlink_vport_get(const char *name, struct dpif_netlink_vport *reply,
                            struct ofpbuf **bufp);
 
-int dpif_netlink_rtm_newneigh(int ifindex, const struct eth_addr src_mac);
-int dpif_netlink_rtm_delneigh(int ifindex, const struct eth_addr src_mac);
+int dpif_netlink_rtm_newneigh(odp_port_t odp_index, int dp_ifindex, const struct eth_addr src_mac);
+int dpif_netlink_rtm_delneigh(odp_port_t odp_index, int dp_ifindex, const struct eth_addr src_mac);
 
 int dpif_netlink_rtm_add_mcast_grp(const void *dpif_, int port_no, const struct in6_addr *addr, uint16_t vlan, const struct eth_addr *mac);
 int dpif_netlink_rtm_del_mcast_grp(const void *dpif_, int port_no, struct in6_addr *addr, uint16_t vlan, const struct eth_addr *mac);
@@ -75,5 +75,6 @@ int dpif_netlink_vport_set_flags(const char *name, uint32_t flags);
 int dpif_netlink_vport_set_carrier(const char *name, bool carrier);
 
 enum ovs_vport_type netdev_to_ovs_vport_type(const char *type);
+int dpif_to_dp_ifindex(void *dpif);
 
 #endif /* dpif-netlink.h */
diff --git a/lib/mac-learning.c b/lib/mac-learning.c
index 6f6891529..67a428ad5 100644
--- a/lib/mac-learning.c
+++ b/lib/mac-learning.c
@@ -30,6 +30,7 @@
 #include "unaligned.h"
 #include "util.h"
 #include "vlan-bitmap.h"
+#include "ofproto/ofproto-dpif.h"
 
 COVERAGE_DEFINE(mac_learning_learned);
 COVERAGE_DEFINE(mac_learning_expired);
@@ -511,9 +512,14 @@ mac_learning_lookup(const struct mac_learning *ml,
 void
 mac_learning_expire(struct mac_learning *ml, struct mac_entry *e)
 {
+    void *port;
+    odp_port_t odp_port;
+
+    port = mac_entry_get_port(ml, e);
+    odp_port = ofbundle_to_odp_port(port);
     ml->need_revalidate = true;
+    dpif_netlink_rtm_delneigh(odp_port, ml->dp_ifindex, e->mac);
     mac_entry_set_port(ml, e, NULL);
-    dpif_netlink_rtm_delneigh(ml->ifindex, e->mac);
     hmap_remove(&ml->table, &e->hmap_node);
     ovs_list_remove(&e->lru_node);
     free(e);
diff --git a/lib/mac-learning.h b/lib/mac-learning.h
index c1050f047..ffb4681b5 100644
--- a/lib/mac-learning.h
+++ b/lib/mac-learning.h
@@ -159,7 +159,7 @@ struct mac_learning {
     struct ovs_refcount ref_cnt;
     struct ovs_rwlock rwlock;
     bool need_revalidate;
-    int ifindex;
+    int dp_ifindex;
 
     /* Statistics */
     uint64_t total_learned;
diff --git a/ofproto/ofproto-dpif-xlate.c b/ofproto/ofproto-dpif-xlate.c
index e458e9d50..5f88cd7b7 100644
--- a/ofproto/ofproto-dpif-xlate.c
+++ b/ofproto/ofproto-dpif-xlate.c
@@ -2572,14 +2572,10 @@ update_learning_table__(const struct xbridge *xbridge,
                         struct xbundle *in_xbundle, struct eth_addr dl_src,
                         int vlan, bool is_grat_arp)
 {
-    struct netdev *netdev;
-    struct xport *xport;
-    xport = CONTAINER_OF(ovs_list_front(&in_xbundle->xports), struct xport,
-                             bundle_node);
-
-    netdev = xport->netdev;
-    xbridge->ml->ifindex = netdev_get_ifindex(netdev);
+    int dp_ifindex;
 
+    dp_ifindex = dpif_to_dp_ifindex(xbridge->dpif);
+    xbridge->ml->dp_ifindex = dp_ifindex;
     return (in_xbundle == &ofpp_none_bundle
             || !mac_learning_update(xbridge->ml, dl_src, vlan,
                                     is_grat_arp,
@@ -2592,12 +2588,17 @@ update_learning_table(const struct xlate_ctx *ctx,
                       struct xbundle *in_xbundle, struct eth_addr dl_src,
                       int vlan, bool is_grat_arp)
 {
+
     if (!update_learning_table__(ctx->xbridge, in_xbundle, dl_src, vlan,
                                  is_grat_arp)) {
+        struct xport *xport;
+
         xlate_report_debug(ctx, OFT_DETAIL, "learned that "ETH_ADDR_FMT" is "
                            "on port %s in VLAN %d",
                            ETH_ADDR_ARGS(dl_src), in_xbundle->name, vlan);
-        dpif_netlink_rtm_newneigh(ctx->xbridge->ml->ifindex, dl_src);
+        xport = CONTAINER_OF(ovs_list_front(&in_xbundle->xports), struct xport,
+                             bundle_node);
+        dpif_netlink_rtm_newneigh(xport->odp_port, ctx->xbridge->ml->dp_ifindex, dl_src);
     }
 }
 
diff --git a/ofproto/ofproto-dpif.c b/ofproto/ofproto-dpif.c
index 8a72ca682..5c5d28cf8 100644
--- a/ofproto/ofproto-dpif.c
+++ b/ofproto/ofproto-dpif.c
@@ -6678,6 +6678,15 @@ odp_port_to_ofport(const struct dpif_backer *backer, odp_port_t odp_port)
     return NULL;
 }
 
+odp_port_t
+ofbundle_to_odp_port(void *port)
+{
+    struct ofport_dpif *ofport;
+
+    ofport = ofbundle_get_a_port((struct ofbundle*) port);
+    return ofport->odp_port;
+}
+
 static ofp_port_t
 odp_port_to_ofp_port(const struct ofproto_dpif *ofproto, odp_port_t odp_port)
 {
diff --git a/ofproto/ofproto-dpif.h b/ofproto/ofproto-dpif.h
index 7499d2409..4af3badf4 100644
--- a/ofproto/ofproto-dpif.h
+++ b/ofproto/ofproto-dpif.h
@@ -289,6 +289,7 @@ extern struct shash all_dpif_backers;
 struct ofport_dpif *odp_port_to_ofport(const struct dpif_backer *, odp_port_t);
 
 odp_port_t ofp_port_to_odp_port_ext(const struct ofproto_dpif *ofproto, ofp_port_t ofp_port);
+odp_port_t ofbundle_to_odp_port(void *port);
 
 /* A bridge based on a "dpif" datapath. */
 
